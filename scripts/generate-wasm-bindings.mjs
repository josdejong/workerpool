#!/usr/bin/env node
/**
 * WASM Bindings Generator
 *
 * Generates TypeScript type definitions from the compiled AssemblyScript module.
 * Also creates embedded WASM for bundled distribution.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT_DIR = path.resolve(__dirname, '..');

// Configuration
const WASM_PATH = path.join(ROOT_DIR, 'dist', 'workerpool.wasm');
const WAT_PATH = path.join(ROOT_DIR, 'dist', 'workerpool.wat');
const OUTPUT_DIR = path.join(ROOT_DIR, 'src', 'generated');
const EMBEDDED_WASM_PATH = path.join(OUTPUT_DIR, 'embeddedWasm.ts');
const WASM_TYPES_PATH = path.join(OUTPUT_DIR, 'wasmTypes.ts');

/**
 * Parse WAT file to extract exported functions and their signatures
 */
function parseWatExports(watContent) {
  const exports = [];

  // Match export declarations: (export "name" (func $name))
  const exportRegex = /\(export\s+"([^"]+)"\s+\(func\s+\$([^)]+)\)/g;
  let match;

  while ((match = exportRegex.exec(watContent)) !== null) {
    exports.push({
      exportName: match[1],
      funcName: match[2],
    });
  }

  // Also parse function signatures
  const funcSignatures = new Map();
  const funcRegex = /\(func\s+\$([^\s(]+)\s*(?:\(export[^)]*\))?\s*(\([^)]*\))*\s*(?:\(result\s+([^)]+)\))?/g;

  while ((match = funcRegex.exec(watContent)) !== null) {
    const funcName = match[1];
    const params = match[2] || '';
    const result = match[3] || 'void';

    // Parse parameters
    const paramTypes = [];
    const paramRegex = /\(param\s+(?:\$\w+\s+)?(\w+)\)/g;
    let paramMatch;
    while ((paramMatch = paramRegex.exec(params)) !== null) {
      paramTypes.push(watTypeToTS(paramMatch[1]));
    }

    funcSignatures.set(funcName, {
      params: paramTypes,
      result: watTypeToTS(result),
    });
  }

  return exports.map(exp => ({
    ...exp,
    signature: funcSignatures.get(exp.funcName) || { params: [], result: 'void' },
  }));
}

/**
 * Convert WAT type to TypeScript type
 */
function watTypeToTS(watType) {
  const typeMap = {
    'i32': 'number',
    'i64': 'bigint',
    'f32': 'number',
    'f64': 'number',
    'void': 'void',
    'v128': 'unknown',
  };
  return typeMap[watType] || 'unknown';
}

/**
 * Generate TypeScript interface from exports
 */
function generateTypeScript(exports) {
  const lines = [
    '/**',
    ' * Auto-generated WASM type definitions',
    ' * DO NOT EDIT - Generated by scripts/generate-wasm-bindings.mjs',
    ' */',
    '',
    '/** WASM module exports interface */',
    'export interface WasmModuleExports {',
  ];

  // Add memory export
  lines.push('  /** WebAssembly linear memory */');
  lines.push('  memory: WebAssembly.Memory;');
  lines.push('');

  // Add function exports
  for (const exp of exports) {
    const { exportName, signature } = exp;
    const params = signature.params.map((t, i) => `arg${i}: ${t}`).join(', ');
    const returnType = signature.result;

    lines.push(`  /** ${exportName} */`);
    lines.push(`  ${exportName}(${params}): ${returnType};`);
    lines.push('');
  }

  lines.push('}');
  lines.push('');

  // Add known exports list
  lines.push('/** List of exported function names */');
  lines.push('export const WASM_EXPORTS = [');
  for (const exp of exports) {
    lines.push(`  '${exp.exportName}',`);
  }
  lines.push('] as const;');
  lines.push('');

  lines.push('export type WasmExportName = typeof WASM_EXPORTS[number];');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generate embedded WASM as base64
 */
function generateEmbeddedWasm(wasmBuffer) {
  const base64 = wasmBuffer.toString('base64');

  return `/**
 * Auto-generated embedded WASM module
 * DO NOT EDIT - Generated by scripts/generate-wasm-bindings.mjs
 */

/** Base64-encoded WASM binary */
export const EMBEDDED_WASM_BASE64 = '${base64}';

/** WASM binary size in bytes */
export const EMBEDDED_WASM_SIZE = ${wasmBuffer.length};

/**
 * Decode embedded WASM to Uint8Array
 */
export function decodeEmbeddedWasm(): Uint8Array {
  if (typeof atob === 'function') {
    // Browser
    const binary = atob(EMBEDDED_WASM_BASE64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
  } else {
    // Node.js
    return new Uint8Array(Buffer.from(EMBEDDED_WASM_BASE64, 'base64'));
  }
}

/**
 * Get embedded WASM as ArrayBuffer
 */
export function getEmbeddedWasmBuffer(): ArrayBuffer {
  return decodeEmbeddedWasm().buffer;
}
`;
}

/**
 * Main function
 */
async function main() {
  console.log('WASM Bindings Generator');
  console.log('=======================\n');

  // Ensure output directory exists
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  // Check if WASM file exists
  if (!fs.existsSync(WASM_PATH)) {
    console.log(`⚠️  WASM file not found at ${WASM_PATH}`);
    console.log('   Run "npm run build:wasm" first to compile AssemblyScript.\n');

    // Generate stub files
    const stubTypes = `/**
 * Stub WASM type definitions
 * Run "npm run build:wasm" to generate actual bindings
 */

export interface WasmModuleExports {
  memory: WebAssembly.Memory;
  // Exports will be generated after WASM compilation
}

export const WASM_EXPORTS = [] as const;
export type WasmExportName = string;
`;

    fs.writeFileSync(WASM_TYPES_PATH, stubTypes);
    console.log(`✓ Generated stub types at ${WASM_TYPES_PATH}`);

    const stubEmbedded = `/**
 * Stub embedded WASM
 * Run "npm run build:wasm" to generate actual embedded WASM
 */

export const EMBEDDED_WASM_BASE64 = '';
export const EMBEDDED_WASM_SIZE = 0;

export function decodeEmbeddedWasm(): Uint8Array {
  throw new Error('WASM not compiled. Run "npm run build:wasm" first.');
}

export function getEmbeddedWasmBuffer(): ArrayBuffer {
  throw new Error('WASM not compiled. Run "npm run build:wasm" first.');
}
`;

    fs.writeFileSync(EMBEDDED_WASM_PATH, stubEmbedded);
    console.log(`✓ Generated stub embedded WASM at ${EMBEDDED_WASM_PATH}`);

    return;
  }

  // Read WASM binary
  console.log(`Reading WASM from ${WASM_PATH}...`);
  const wasmBuffer = fs.readFileSync(WASM_PATH);
  console.log(`  Size: ${wasmBuffer.length} bytes\n`);

  // Generate embedded WASM
  console.log('Generating embedded WASM...');
  const embeddedCode = generateEmbeddedWasm(wasmBuffer);
  fs.writeFileSync(EMBEDDED_WASM_PATH, embeddedCode);
  console.log(`✓ Generated ${EMBEDDED_WASM_PATH}\n`);

  // Parse WAT for type information if available
  if (fs.existsSync(WAT_PATH)) {
    console.log('Parsing WAT for type information...');
    const watContent = fs.readFileSync(WAT_PATH, 'utf8');
    const exports = parseWatExports(watContent);
    console.log(`  Found ${exports.length} exports\n`);

    // Generate TypeScript types
    console.log('Generating TypeScript types...');
    const tsCode = generateTypeScript(exports);
    fs.writeFileSync(WASM_TYPES_PATH, tsCode);
    console.log(`✓ Generated ${WASM_TYPES_PATH}\n`);
  } else {
    console.log('⚠️  WAT file not found, skipping type generation');
  }

  console.log('Done!');
}

main().catch(err => {
  console.error('Error:', err);
  process.exit(1);
});
